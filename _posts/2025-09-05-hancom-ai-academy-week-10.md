---
title: "[스나이퍼팩토리] 한컴AI 2기 - 교육 10주차 후기"
description: >-
  Python 의 기본 문법 및 파일 입출력 학습, 이를 바탕으로 '숫자 맞히기 게임'과 파일 입출력을 활용한 '메모 관리 시스템'을 직접 구현한 과정 정리.
author: gisoun
date: 2025-09-07 21:09:00 +0900
categories: [Hancom AI Academy, Education]
tags: [hancom, hancom ai academy, education, ai, python]
pin: false
media_subpath: '/assets/posts/20250905'
published: true
---

> 2025\. 9\. 1\. ~ 2025\. 9\. 5\.

---

10주차 교육부터는 주력 기술이 **Node.js**에서 **Python** 으로 전환되었습니다. 이번 포스팅에서는 Python 의 핵심 기초 문법인 연산자, 표현식, 조건문, 반복문, 그리고 파일 입출력을 학습하고, 배운 내용을 응용하여 터미널 환경에서 동작하는 **'숫자 맞히기 게임'**과 **'메모 관리 시스템'** 실습 내용을 공유합니다.

---

## 연산자와 표현식

프로그래밍의 가장 기본이 되는 데이터 처리 방법을 배우는 시간이었습니다. **연산자(Operator)**는 덧셈, 뺄셈과 같이 데이터를 특정 방식으로 처리하는 기호이며, 연산의 대상이 되는 값을 **피연산자(Operand)**라고 합니다.

### 주요 연산자 종류

- **`산술 연산자`**: **`+`**, **`-`**, **`*`**, **`/`** 와 같은 기본적인 사칙연산 기호입니다. Python 에서는 나머지(**`%`**), 몫(**`//`**), 거듭제곱(**`**`**)을 구하는 연산자도 제공합니다.
- **`비교 연산자`**: **`==`**(같다), **`!=`**(다르다), **`>`**(크다), **`<`**(작다) 등 두 값을 비교하여 **`True`** 또는 **`False`** 의 결과를 반환합니다.
- **`논리 연산자`**: **`and`**(그리고), **`or`**(또는), **`not`**(아니다) 키워드를 사용하여 여러 조건의 **참/거짓**을 조합합니다.
- **`할당 연산자`**: = 기호를 사용하여 변수에 값을 할당합니다. **`a += 5`** 와 같이 다른 연산자와 결합하여 **`a = a + 5`** 의 의미로 축약해서 사용할 수도 있습니다.
- **`멤버 연산자`**: **`in`**, **`not in`** 키워드를 사용하여 특정 값이 리스트나 문자열과 같은 시퀀스 자료형에 포함되어 있는지 확인합니다.



> 이러한 연산자들은 정해진 **우선순위**에 따라 계산됩니다.
> 예를 들어, 곱셈과 나눗셈은 덧셈과 뺄셈보다 먼저 계산되며, 괄호 **`()`**를 사용하면 우선순위를 가장 높일 수 있습니다.
{: .prompt-info }

---

## 조건문과 반복문

Python 에서의 조건문과 반복문에 대해 배웠습니다.

### 조건문

**`if`** 문은 주어진 조건이 참(**`True`**)일 경우에만 특정 코드 블록을 실행합니다. **`else`** 문은 **`if`** 조건이 거짓(**`False`**)일 때 실행될 코드를 지정하며, **`elif (else if)`**를 사용하면 여러 조건을 순차적으로 검사할 수 있습니다.

```python
age = int(input("나이를 입력하세요: "))

if age < 13:
    print("어린이입니다.")
elif age < 20:
    print("청소년입니다.")
else:
    print("성인입니다.")
```

### 반복문

**`for`** 문은 리스트, 튜플, 문자열 등 반복 가능한 객체의 요소를 하나씩 순회하며 코드를 실행합니다. **`range()`** 함수와 함께 사용하면 정해진 횟수만큼 코드를 반복하는 데 유용합니다.

```python
# 0부터 4까지 5번 반복
for i in range(5):
    print(i)

# 리스트의 모든 요소 출력
animals = ["dog", "cat", "tiger"]
for animal in animals:
    print(animal)
```

**`while`** 문은 주어진 조건이 참인 동안 계속해서 코드를 반복합니다. 반복을 끝내기 위해서는 조건이 언젠가 거짓이 되도록 만들어야 하며, **`while True:`** 와 같이 무한 루프를 만들고 내부에서 **`break`** 문으로 탈출하는 방식도 자주 사용됩니다.

- **`break`**: 현재 실행 중인 반복문을 즉시 완전히 종료합니다.
- **`continue`**: 반복문의 현재 실행을 건너뛰고 다음 반복을 계속 진행합니다.

이러한 조건문과 반복문은 서로 **중첩하여 사용**할 수 있습니다. 예를 들어, **`for`** 문 안에 또 다른 **`for`** 문을 넣어 2차원 데이터를 다루거나(구구단 출력 등), **`for`** 문 안에 **`if`** 문을 넣어 특정 조건에 맞는 요소에 대해서만 작업을 수행할 수 있습니다.

---

## 숫자 맞히기 게임

강의 내용을 종합하여 간단한 **'숫자 맞히기 게임'**을 만들어보는 실습을 진행했습니다. Python 의 변수, 연산자, 조건문, 반복문을 모두 활용하는 좋은 예제였습니다.

### 게임 규칙

1. 사용자는 1부터 1000 사이의 **시드(seed)** 번호를 입력하여 랜덤 숫자를 생성합니다. 시드 번호가 같으면 항상 같은 숫자가 생성됩니다.
2. 컴퓨터는 1부터 100 사이의 정답 숫자를 하나 생성합니다.
3. 사용자에게는 총 20번의 기회가 주어집니다.
4. 사용자가 숫자를 입력하면, 컴퓨터는 정답이 사용자의 숫자보다 '큰지' 또는 '작은지' 힌트를 줍니다.
5. 정답을 맞히거나 20번의 기회를 모두 사용하면 게임이 종료됩니다.

### 구현 코드

```python
from random import randint, seed

print('먼저 1 ~ 1000 사이의 시드 번호를 입력해 주세요.')

seed_num = int(input('시드 번호 (1-1000): '))

if 1 > seed_num or seed_num > 1000:
    print('1 ~ 1000 사이의 시드 번호를 입력해 주세요.')
    exit(1)

seed(seed_num)

print(f'새로운 숫자가 생성되었습니다! (시드: {seed_num})')
print('1 ~ 100 사이의 숫자를 맞혀보세요!')

answer = randint(1, 100)

retryLimit = 20
print(f'{retryLimit}번의 기회가 있습니다.')

for cnt in range(1, retryLimit + 1):
    retry = int(input(f'시도 {cnt}: 숫자를 입력하세요 (1-100): '))
    retryLeft = retryLimit - cnt # 남은 기회 계산

    if answer > retry:
        print(f'({retry} 입력) 더 큰 수를 입력하세요! (남은 기회: {retryLeft}번)')
    elif answer < retry:
        print(f'({retry} 입력) 더 작은 수를 입력하세요! (남은 기회: {retryLeft}번)')
    else:
        print(f'정답입니다! {cnt}번 만에 맞히셨습니다!')
        print(f'총 시도 횟수: {cnt}번 (정답: {answer})')
        break
```

---

## 메모 관리 시스템

Python 의 기본적인 제어문 학습에 이어, **파일 입출력(File I/O)** 기능을 활용하여 콘솔 기반의 간단한 **메모 관리 시스템**을 만드는 실습을 진행했습니다. 파일 입출력은 프로그램이 종료되더라도 데이터를 영구적으로 보존할 수 있게 해주는 핵심적인 기능입니다.

### 파일 입출력의 기초

Python 에서는 **`open()`** 함수를 사용하여 파일을 열고, 파일 객체를 통해 내용을 읽거나 쓸 수 있습니다. 파일을 다 사용한 후에는 반드시 **`close()`** 메서드로 닫아주어야 하지만, **`with open(...) as f:`** 구문을 사용하면 코드 블록이 끝날 때 파일이 자동으로 닫히므로 더 안전하고 권장되는 방식입니다.

- **`파일 열기 모드`**
  - **`'r'`** (읽기): 파일을 읽기 전용으로 엽니다. (기본값)
  - **`'w'`** (쓰기): 파일에 내용을 씁니다. 파일이 이미 존재하면 내용을 덮어씁니다.
  - **`'a'`** (추가): 파일의 끝에 내용을 추가합니다.
- **`파일 읽기 메서드`**
  - **`read()`**: 파일 전체 내용을 하나의 문자열로 읽어옵니다.
  - **`readline()`**: 파일에서 한 줄씩 읽어옵니다.
  - **`readlines()`**: 파일의 모든 줄을 리스트 형태로 읽어옵니다.

### 메모 관리 시스템의 주요 기능

이 시스템은 터미널 환경에서 동작하며, 사용자는 메뉴 선택을 통해 아래과 같은 기능을 수행할 수 있습니다.

1. **`새 메모 작성`**: 제목과 내용을 입력받아 새로운 **`.txt`** 파일을 생성합니다. 파일명에는 중복을 피하기 위해 생성 시점의 타임스탬프를 포함시켰습니다.
2. **`메모 목록 보기`**: 지정된 디렉토리(**`memos/`**)에 있는 모든 메모 파일의 목록을 보여줍니다.
3. **`메모 읽기`**: 목록에서 번호를 선택하여 특정 메모의 제목, 최종 수정 일시, 내용을 확인합니다.
4. **`메모 수정`**: 기존 메모의 내용을 새로 입력한 내용으로 덮어씁니다.
5. **`메모 삭제`**: 선택한 메모 파일을 시스템에서 영구적으로 삭제합니다.
6. **`종료`**: 프로그램을 마칩니다.

### 구현 코드

```python
import time
import datetime
import os

memo_dir = './memos' # 메모를 저장할 디렉토리

# 메모 목록을 보여주는 함수
def view_memo_list():
    print('===== 메모 목록 =====')
    if not os.path.exists(memo_dir):
        os.makedirs(memo_dir)
    
    memo_list = os.listdir(memo_dir)
    for i, memo in enumerate(memo_list):
        print(f'{i + 1}. {memo}')
    return memo_list

while True:
    print('\\n===== 파일 기반 메모 관리 시스템 =====')
    print('1. 새 메모 작성')
    # ... (메뉴 출력) ...
    print('6. 종료')
    print('=====================================')

    menu = input('원하는 작업 메뉴 선택 (1 ~ 6): ')

    if menu == '1': # 새 메모 작성
        title = input('메모 제목: ')
        # 파일명 중복 방지를 위해 타임스탬프 추가
        filename = f'{int(time.time())}_{title}.txt'
        content = input('메모 내용:\\n> ')
        
        with open(os.path.join(memo_dir, filename), 'w', encoding='utf-8') as f:
            f.write(content)
            print('새 메모가 작성되었습니다.')

    elif menu == '3': # 메모 읽기
        memo_list = view_memo_list()
        if not memo_list:
            print('읽을 수 있는 메모가 없습니다.')
            continue
        
        try:
            selected_num = int(input('\\n읽을 메모 번호: '))
            memo_file = memo_list[selected_num - 1]
            memo_path = os.path.join(memo_dir, memo_file)

            with open(memo_path, 'r', encoding='utf-8') as f:
                # ... (메모 제목, 수정 시간, 내용 출력) ...
                print(f"--- {memo_file} ---")
                print(f.read())
                print("--------------------")
        except (ValueError, IndexError):
            print("잘못된 번호입니다.")

            
    # ... (다른 메뉴 기능 구현) ...

    elif menu == '6':
        print('프로그램을 종료합니다.')
        break
```

---

## 마무리

10주차는 Python 과 친숙해지는 중요한 시간이었습니다. 기본 문법부터 시작하여 제어문, 그리고 파일 입출력까지, Python 프로그래밍의 뼈대를 이루는 개념들을 탄탄히 다졌습니다. 특히 **'숫자 맞히기 게임'**과 **'메모 관리 시스템'** 같은 실습을 진행함으로써, 이론으로만 배우는 것보다 훨씬 깊이 있게 익힐 수 있었습니다.

---

본 후기는 [한글과컴퓨터x한국생산성본부x스나이퍼팩토리] 한컴 AI 아카데미 2기 (B-log) 리뷰로 작성 되었습니다.

#한컴AI아카데미2기 #AI개발자 #AI개발자교육 #한글과컴퓨터 #한국생산성본부 #스나이퍼팩토리 #부트캠프 #AI전문가양성 #개발자교육 #개발자취업
